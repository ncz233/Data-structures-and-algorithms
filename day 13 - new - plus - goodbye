#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>
//查找和排序
//排序:
// 冒泡
// 插入
// 选择
// 快速排序(用的比较多)
// 归并排序
// ...

//冒泡排序(升序)
//void sort(int* a, int n);//a是数组，n是有效长度
//{
//	int i, j;
//	int t;
//	for ( i = 0; i < n-1; i++)//这里是除了自己全部排一遍，排的次数(一共排序的次数)
//	{
//		for ( j = 0; j < n-i-1; j++)//开始排了(一个这么排)
//		{
//			if (a[j]>a[j+1])
//			{
//				t = a[j];
//				a[j] = a[j + 1];
//				a[j + 1] = t;
//			}
//		}
//	}
//}

//插入排序(后一个插入前面的数据，保证有序)

//选择排序(升序：在数组中选择最小值，跟第一个值互换，然后再从数组中选择次最小值，跟第二个值互换，然后以此类推)
//void sort(int* a, int len)
//{
//	int i, j, min, t;
//	for ( i = 0; i < len-1; i++)//一共排的次数
//	{
//		for (min = i, j = i+1; j < len; j++)//min是前一个
//		{
//			if (a[min] > a[j])
//			{
//				min = j;
//			}
//		}
//		if (min != i)
//		{
//			t = a[i];
//			a[i] = a[min];
//			a[min] = t;
//		}
//	}
//}
//int main()
//{
//	int a[] = { 3,2,1 };
//	int len = sizeof(a) / sizeof(a[0]);
//	sort(a, len);
//	for (int i = 0; i < len; i++)
//	{
//		printf("%d ", a[i]);
//	}
//
//	return 0;
//}

//归并排序(先两个两个有序，后四个四个有序，然后是八个八个有序，以此类推)

//快排(先吧第一个元素位置的最终位置给确定，然后把数据分成左边一半和右边一半，同样先把左边的第一个元素给确定了，然后有分了两半,以此类推直到剩下一个，另一半也是如此)
//(就是劈两半，直到最后一个为止。最关键的是找到第一个元素的确切位置)
//思路：定义两个指针，一个指第一个元素，一个指最后一个元素。看最后一指向的元素，比第一个元素值小的赋值给第一个指针，比第一个值大的向左移动直到比第一个值小然后赋值给第一个指针，赋值完后不要移动了。然后移动被赋值的指针(也就是第一个指针)，移动如果值比第一个元素小移动直到比第一个元素大停下，然后把这个指针指向的元素赋给后一个指针(也就是之前那赋过值的指针)，这个指针不要移动了。移动后一个指针移动的时候如果值比第一个元素值大移动，小就不移动赋值给前一个指针，按照这个规定走下去有.....
//简便的思路：定义两个指针，一个指第一个元素(前一个指针)，一个指最后一个元素(后一个指针)。看后一个指针的值，如果比第一个元素大移动到上一位直到小于第一个元素并赋值给前一个指针，小就直接赋值前一个指针。然后移动前一个指针，比第一个元素小移动到下一位直到大于第一个元素并赋值给后一个指针(因为是已经赋过值，这个值一定比第一个元素小，所以就不用判断)。重复这个步骤，直到两个指针指向同一个元素为止
//依据上面铺垫：要排序的元素。前一个指针是(就是指向要排序的元素)，后一个指针(就是从要排序的元素到排完序的 前/后 一个元素。)然后前指针是比要排序的元素小，只要大把这个值赋给后一个元素。后一个指针是比要排序的元素大，小就赋值给前一个指针。注意：操作后一个指针

//例子 - 第一次
// 5268437
// 3245867
//

//写快排 - (快排与堆排都是属于同一种类型的，基本上都是一样的，无非细节上有点区别)
void QuickSort(int* a, int low ,int high);
//找出每个递归的首地址和一开是的首地址
int FindPos(int* a, int low, int high);
int main()
{
	int a[] = { 2,1,0,-5,4,-3 };
	int high = sizeof(a) / sizeof(a[0]);
	int low = 0;
	QuickSort(a, low, high-1);
	for (int i = 0; i < high; i++)
	{
		printf("%d ", a[i]);
	}
	return 0;
}

void QuickSort(int* a, int low, int high)
{
	int pos;
	if (low < high)
	{
		pos = FindPos(a, low, high);//找到第一个元素的确切位置
		QuickSort(a, low, pos-1);//左边一半
		QuickSort(a, pos+1, high);//右边一般
	}
}

int FindPos(int* a, int low, int high)
{
	int val = a[low];
	while (low < high)
	{
		while (low < high&&a[high] >= val)//前一个指针
		{
			high--;
		}
		a[low] = a[high];
		while (low < high && a[low] <= val)//后一个指针
		{
			low++;
		}
		a[high] = a[low];
	}
	//终止while循环后low和high一定是相等的
	a[low] = val;
	return high;//high可以改为low，但不能改为val，也不能是a[low] a[high]
}

//=================学完了！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！！。有缘再见，有点伤感！
