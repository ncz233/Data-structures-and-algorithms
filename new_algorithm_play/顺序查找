///////////////////////////////////////dataMlment.h
#pragma once

//定义数据元素
#define MAX_SIZE 255
#define MAX_RECORD_SIZE 50
#define TRUE 1
#define FALSE 0

//查询关键字类型
typedef int KeyType;
typedef char InfoType;

//定义查询的数据类型
typedef struct
{
	KeyType id;//查询关键字
	InfoType* name;//数据域
}ElmentType;

//定义顺序表
typedef struct
{
	ElmentType* datas;//顺序表中数据元素集合
	int length;//顺序表中的元素个数
}seqList;



/////////////////////////////////////////seqList.h
#pragma once

#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include"dataElment.h"

//初始化顺序表
void InitSeqList(seqList* seqlist);

//打印函数
void printSeqList(seqList* seqlist);

//查找顺序查找,根据查找关键字key返回元素在顺序表中的顺序(从1开始没找到返回0)
int SearchSeqList1(seqList* seqlist, KeyType key);

//查找2号版本,改进版的二号版本
int SearchSeqList2(seqList* seqlist, KeyType key);


//测试
void TestSeqListSearch();



/////////////////////////////////////////////////////////seqList.c
#define _CRT_SECURE_NO_WARNINGS 1

#include"SeqList.h"

//初始化顺序表
void InitSeqList(seqList* seqlist)
{
	seqlist->datas = (ElmentType*)malloc(sizeof(ElmentType) * MAX_SIZE);//注意起始位置不存元素,
	//存代查找关键字key存入表头("哨兵位"),从后向前逐个比较,可免去查找过程中每一步都要检测是否查找完毕,加快速度

	seqlist->length = 0;
}

//打印函数
void printSeqList(seqList* seqlist)
{
	for (int i = 1; i <= seqlist->length; i++)//第一个位置不放元素,做哨兵位
	{
		printf("%d\t%s\n", seqlist->datas[i].id, seqlist->datas[i].name);
	}
}

//查找顺序查找,根据查找关键字key返回元素在顺序表中的顺序(从1开始没找到返回0)
int SearchSeqList1(seqList* seqlist, KeyType key)
{
	for (int i = 1; i < seqlist->length; i++)
	{
		if (seqlist->datas[i].id == key)
		{
			return i;
		}
	}
	return 0;
}

//查找2号版本,改进版的二号版本
int SearchSeqList2(seqList* seqlist, KeyType key)
{
	//第一个位置的元素设置为哨兵
	seqlist->datas[0].id = key;
	int i;
	//原算法中,for循环中有一次判断,for循环体内还会有一次判断
	//改进算法中的,我们只需要判断key值是否相等就可以了,省略了for循环次数的判断
	for (i = seqlist->length; seqlist->datas[i].id != key; i--)
	{
		//null
	}
	return i;

}

//测试
void TestSeqListSearch()
{
	seqList seqlist;
	InitSeqList(&seqlist);
	int keys[] = { 10,40,20,80,2,5,50 };
	char* valuse[] = { "小黑","阿吉","七二","阿凡达","金克拉","的撒给","的风格" };
	int len = sizeof(keys) / sizeof(int);
	for (int i = 1; i <= len; i++)
	{
		seqlist.datas[i].id = keys[i-1];
		seqlist.datas[i].name = (InfoType*)malloc(sizeof(InfoType) * MAX_RECORD_SIZE);
		strcpy(seqlist.datas[i].name, valuse[i - 1]);
		seqlist.length++;
	}
	printf("初始化顺序表\n");
	printSeqList(&seqlist);

	int searchKey = 40;
	int pos = SearchSeqList1(&seqlist, searchKey);
	printf("普通顺序表查找: searchKey = %d, pos = %d\n", searchKey, pos);
	pos = SearchSeqList2(&seqlist, searchKey);
	printf("改进版顺序表查找: searchKey = %d, pos = %d\n", searchKey, pos);

}



///////////////////////////////////////////////////////////////////main.c
#define _CRT_SECURE_NO_WARNINGS 1

#include"SeqList.h"
#include<math.h>

int main()
{
	TestSeqListSearch();
	return 0;
}
