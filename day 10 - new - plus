#define _CRT_SECURE_NO_WARNINGS 1

//线性结构的总复习 - 一般大厂考非线性都是伪算法。因为树太复杂了
//逻辑结构
// 线性
//  数组
//  链表
//  栈和队列是一种特殊的线性结构
// 非线性
//  树
//  图
//物理结构
//

//树
//非线性结构 - 大部分的代码都是用递归来解决的(注意：内存本身是一个线性一维的)
//  树 - (可以看成某公司人事图，最上面是老板，然后是领导(领导也不只是一个吧，有多个)，最后一个领导下有多个员工。每一个人事看成一个结点)
//   树的定义 - 以递归的方式来定义
//    专业定义：有且只有一个根的结点。下面有若干个互不相交的子树，这些子树本身是一棵树
//    通俗定义：树是由结点和边组成的(边就是指针域)。每一个结点只有一个父节点，但可以有多个子节点。但有一个结点列外，该节点没有父节点，此节点称为根节点

//   树的专业术语
//    结点 - 父节点 、 子节点 、 子孙(子节点的父节点的父节点的结点，两节点之间差了2层) 、 堂兄弟(子节点的父节点的父节点的另一个子节点的子节点，就是两个结点处于同一层的结点)
//    深度 - 树中从根节点到最底层结点的层数称之为深度 - 根节点是第一层
//    叶子节点 - 没有子节点的结点
//    非终端节点 - 实际就是非叶子结点
//    (注：根节点可以是叶子结点，)
//    度 - 子节点的个数 - 含有最大子节点的的度数叫整个树的度数


//   树的分类
//    一般树 - 任意一个结点的子节点的个数都不受限制，子节点的位置可以被更改(一般树不更改子节点位置是一个有序一般树，反之是一个无序一般树)

//    二叉树 - 任意一个结点的子节点的个数最多两个，且子节点的位置不可被更改(所以二叉树绝对是一个有序树)
//     分类
//      一般二叉树
//      满二叉树 - 专业的词：在不增加树的层数的前提下无法在添加一个结点的二叉树 - 就是在不曾加树的层数前提下，无法再多添加一个结点的二叉树就是满二叉树
//      完全二叉树 - 如果只是删除了满二叉树最底层最右边连续若干个结点，这样形成的二叉树就是完全二叉树 - 就是满二叉树的前提下删除最下面最右边连续的若干的结点 - (在最下层删结点从右向左删除，不能跳着删，只能按顺序从右向左删。)
//       (完全二叉树是搞啥呢，解决数据存储问题，因为我们的二叉树有一种是用数组来存储的，要用数组存储就必须用完全二叉树来实现，这时候就要用到完全二叉树的知识了)
//       (完全二叉树有个特列，就是不删除，也就是这个特列是满二叉树。完全二叉树包含满二叉树)
//       (特点：1.我知道你结点的个数(度)，就知道你有几层。2.你已知任意一个点，你可以知道它的父节点是谁，子节点是谁，还有一个它有没有子节点。)
//       (优点：知道它的子节点、父节点、左字节点、右子结点和有没有子节点很方便，不需要找用一个公式搞定时间复杂度是O(1)反正速度很快。缺点：耗用的内存过大)
//    森林 - N个互不相交的树的集合


//   树的存储
//    一般树的存储 - 转换成二叉树来存储的

//    森林的存储 - 转换成二叉树来存储的

//    二叉树的存储 - 算法比较成熟 - (核心)
//     连续存储[完全二叉树] - 必须先把不满的二叉树转换成满二叉树然后在完全二叉树(就是把右边的垃圾值删了)。解释：这个树有自己的组织方式，你只保存有效的点，导致的结果就是别人只看到这几个点的树，它不知道以前那个树是怎么构造出来的，所以不能只保存有效的点
//      数组是线性结构，树是非线性结构。要把一个非线性以线性来保存，要告诉我规定，那个在前那个在后。所以有3种规定 - 先序，中序，后序。无论那种方式转换后都不能退回去。以数组存储不能只存储它的有效结点，因为你只存它的有效结点导致的结果是，你根据它的内存顺序无法推断出以前的二叉树到底是以什么方式构造出来的
//      我们的二叉树是非线性的，就不能用线性表示，因为非线性不是前面有一个后面有一个，而我们内存是线性的，树是非线性的，所以我们造出了3种规则 - 线序，中序，后续。如果你只存放有效结点导致的结果是无论是先序中序还是后序，你所确定的这个线性的有效结点，你根据它你没法推算出二叉树它以前是什么样子，你推不出来就不能这样去存，想想你存进去不知道以前这个树是什么东西，这个问题还是没解决吗，问题就在这块
//      为什么要把这个树转换成一个完全二叉树，因为你不能够只存有效结点，因为你只存有效结点有两个问题：1.你怎么把一个只有有效的结点的树转换成线性的，有三种规则。2.即便这三种规则确定是哪一种了你存完之后别人从内存里面也无法获取到以前那个树的信息，就是说你这种存储方式是有问题的。那要解决这个问题只能把那些我们没有的或者是那些垃圾的结点也要存起来，这样的话才能把这个树还原，所以说我们对一个树进行存储的时候是不是必须要以完全二叉树的形式去存储(数组)
//      总结：树是非线性的，把一个非线性转换成线性他们结果是不是确定的还是人为指定的，不确定。因为非线性树它不是线性结构，你能直到转换成线性结构是什么数据吗，肯定不知道，也没办法知道，关键是数组是线性的，你只能以线性去存。这里有个问题你本来是一个非线性结构从逻辑上将你就不能用线性去存，因为它不是线性顺序，但你又必须的要用计算机里面的线性硬件去存所以人类只好要造一种规则，规定你怎么用线性去存，规则是先中后序解决问题
//      简洁说结论：树是非线性的，你要用线性去存，你就必须指定转换的方式这个方式就是：先序、中序、后序(而解析结论的过程是在：先序、中序、后续中，因为这是认为定下的规则。已知先中和中后可以推出来树)
//     链式存储
//      二叉树最多只有两个子节点，所以每个结点的指针域至少有2指针个(有两个指向子节点，一个指向父节点，但一般是两个指向子节点的指针)，没子节点指向空。因为指针存在就没必要怎么存了存那都行


//   树的操作 - 还是解决非线性用线性存储的问题
//    双亲表示法 - 求父节点很方便
//     数组实现(利用结构体表示)：一部分存的是数据，一部分存它父亲的下标(谁在前谁在后是确定不了的。正因为确定不了顺序，我们要把它变成二叉树来存(二叉树是有序的，因为一般树是无序的，所以你非得有序转二叉树表示))

//    孩子表示法 - 求子节点很方便
//     链表实现(结构体)：一部分存的是数据，一部分存的是它所有孩子的地址

//    双亲孩子表示法 - 都方便
//     链表和数组方式(结构体)：一部分存的是数据，一部分存它父亲的下标，一部分存的是它所有孩子的地址(要有链表(好多个链表)，要有数组(不是普通的数组，每一个数组分三部分，每一部分的数据类型不一样))

//    二叉树表示法 - 主要
//     把一个普通树转化成二叉树来存储，具体转换方法：(一般树转换成二叉树一定没有右子树的)
//      设法保证做任意一个结点的
//       左指针指向第一个孩子
//       右指针指向它的兄弟
//      只要能满足此条件，就可以把一个普通树转化为二叉树
