///////////////////////////////////GraphModel.h
#pragma once
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

//表示
#define OK 1
#define ERROR 0
#define MAX_VERTEX 100 //顶点的总数

//图的类型枚举
typedef enum
{
	DG,//有向图 == 0
	UDG,//无向图 == 1
	DN,//有向网 == 2
	UDN//无向网 == 3

}GraphKind;

//顶点的数据类型为字符型,使用时记得malloc分配内存
typedef	char VerTexType;

//设置权值类型为整数类型
typedef int ArcType;

//返回的状态类型
typedef	int Status;


///////////////////////////////////////////MatrixGraph.h
#pragma once
//数组的邻接矩阵表示法

#include "GraphModel.h"

//图的邻接矩阵存储表示
typedef struct
{
	//顶点数组(一共能存放多少个顶点)
	VerTexType* verTexS[MAX_VERTEX];
	//权数组
	ArcType arcs[MAX_VERTEX][MAX_VERTEX];//邻接矩阵(权数组)

	//图的顶点数量
	int verTexCount;
	//图的边或弧数量
	int arcCount;

	//图的类型
	GraphKind kind;

}MarixGraph;

//使用邻接矩阵创建无向图
Status CreateUDG(MarixGraph* G);

//使用邻接矩阵创建有向图
Status CreateDG(MarixGraph* G);

//无向网就是把邻接矩阵的1改成权值就行
Status CreateUDN(MarixGraph* G);

//有向网就是把不对称的无向网
Status CreateDN(MarixGraph* G);

//返回某个顶点在顶点集合中的下标(从0开始),不存在返回-1
int LocateVex(MarixGraph* G, VerTexType* vex);

void testMatrixGrqph();


/////////////////////////////////////////////MatrixGraph.c
#define _CRT_SECURE_NO_WARNINGS 1
#include"MatrixGraph.h"

//使用邻接矩阵表示法创建无向图
//无向图的特点
// 无向图的邻接矩阵是对称的
// 顶点i的度 = 第i行(列)中1的个数
// 
//
//在有向图的邻接矩阵中
//  第i行含义:以节点vi为尾的弧(既出度边)
//  第i列含义:以节点vi为尾的弧(既入度边)
//有向图特点
// 有向图的邻接矩阵可能不是对称的
// 顶点的出度 = 第i行元素之和
// 顶点的入度 = 第i列元素之和
// 顶点的度 = 第i行元素之和 + 第i列元素之和
//

//使用邻接矩阵创建无向图
Status CreateUDG(MarixGraph* G)
{
	G->kind = UDG;//设置当前创建图的类型为无向图

	printf("请输入无向图的顶点数量\n");
	scanf("%d", &G->verTexCount);
	printf("边的数量\n");
	scanf("%d", &G->arcCount);
	
	printf("依次输入顶点信息\n");
	for (int i = 0; i < G->verTexCount; i++)
	{
		G->verTexS[i] = (VerTexType*)malloc(sizeof(VerTexType) * 10);//数组类型,整形的char类型
		printf("顶点%d:",i+1);
		scanf("%s", G->verTexS[i]);
	}

	//初始邻接矩阵所有边的权值设置为0
	for (int i = 0; i < G->verTexCount; i++)
	{
		for (int j = 0; j < G->verTexCount; j++)
		{
			G->arcs[i][j] = 0;//默认为0
		}
	}

	printf("请输入顶点和临界顶点信息,构建邻接矩阵\n");
	for (int i = 0; i < G->arcCount; i++)
	{
		VerTexType* vex1 = (VerTexType*)malloc(sizeof(VerTexType) * 10);
		VerTexType* vex2 = (VerTexType*)malloc(sizeof(VerTexType) * 10);

		printf("顶点:");
		scanf("%s", vex1);
		printf("临界点(与顶点相连的点):");
		scanf("%s", vex2);

		//分别获得两个顶点在顶点数组中的坐标
		//int x, y;
		int x = LocateVex(G, vex1);
		int y = LocateVex(G, vex2);
		if (x == -1 || y == -1)
		{
			return ERROR;
		}
		G->arcs[x][y] = 1;
		//无向图邻接表是对称的
		G->arcs[y][x] = G->arcs[x][y];

		free(vex1);
		free(vex2);
	}

	return OK;
}

//返回某个顶点在顶点集合中的下标(从0开始),不存在返回-1
int LocateVex(MarixGraph* G, VerTexType* vex)
{
	int index = 0;
	while (index < G->verTexCount)
	{
		if (strcmp(G->verTexS[index], vex) == 0)
		{
			break;
		}
		index++;
	}
	return index == G->verTexCount ? -1 : index;
}

//使用邻接矩阵创建有向图
//有向图特点
// 有向图的邻接矩阵可能不是对称的
// 顶点的出度 = 第i行元素之和
// 顶点的入度 = 第i列元素之和
// 顶点的度 = 第i行元素之和 + 第i列元素之和
//
Status CreateDG(MarixGraph* G)
{
	G->kind = DG;//设置当前创建图的类型为有向图

	printf("请输入有向图的顶点数量\n");
	scanf("%d", &G->verTexCount);
	printf("边的数量\n");
	scanf("%d", &G->arcCount);

	printf("依次输入顶点信息\n");
	for (int i = 0; i < G->verTexCount; i++)
	{
		G->verTexS[i] = (VerTexType*)malloc(sizeof(VerTexType) * 10);//数组类型,整形的char类型
		printf("顶点%d:", i + 1);
		scanf("%s", G->verTexS[i]);
	}

	//初始邻接矩阵所有边的权值设置为0
	for (int i = 0; i < G->verTexCount; i++)
	{
		for (int j = 0; j < G->verTexCount; j++)
		{
			G->arcs[i][j] = 0;//默认为0
		}
	}

	printf("请输入顶点和临界顶点信息,构建邻接矩阵\n");
	for (int i = 0; i < G->arcCount; i++)
	{
		VerTexType* vex1 = (VerTexType*)malloc(sizeof(VerTexType) * 10);
		VerTexType* vex2 = (VerTexType*)malloc(sizeof(VerTexType) * 10);

		printf("顶点:");
		scanf("%s", vex1);
		printf("临界点(与顶点相连的点):");
		scanf("%s", vex2);

		//分别获得两个顶点在顶点数组中的坐标
		//int x, y;
		int x = LocateVex(G, vex1);
		int y = LocateVex(G, vex2);
		if (x == -1 || y == -1)
		{
			return ERROR;
		}
		G->arcs[x][y] = 1;
		//有向图的邻接矩阵有可能不对称
		//G->arcs[y][x] = G->arcs[x][y];

		free(vex1);
		free(vex2);
	}

	return OK;
}

//无向网就是把邻接矩阵的1改成权值就行
Status CreateUDN(MarixGraph* G)
{
	G->kind = UDN;//设置当前创建图的类型为无向网

	printf("请输入无向网的顶点数量\n");
	scanf("%d", &G->verTexCount);
	printf("边的数量\n");
	scanf("%d", &G->arcCount);

	printf("依次输入顶点信息\n");
	for (int i = 0; i < G->verTexCount; i++)
	{
		G->verTexS[i] = (VerTexType*)malloc(sizeof(VerTexType) * 10);//数组类型,整形的char类型
		printf("顶点%d:", i + 1);
		scanf("%s", G->verTexS[i]);
	}

	//初始邻接矩阵所有边的权值设置为0
	for (int i = 0; i < G->verTexCount; i++)
	{
		for (int j = 0; j < G->verTexCount; j++)
		{
			G->arcs[i][j] = INT_MAX;//默认为整形最大值,代表无穷大
		}
	}

	printf("请输入顶点和临界顶点信息,构建邻接矩阵\n");
	for (int i = 0; i < G->arcCount; i++)
	{
		VerTexType* vex1 = (VerTexType*)malloc(sizeof(VerTexType) * 10);
		VerTexType* vex2 = (VerTexType*)malloc(sizeof(VerTexType) * 10);

		printf("顶点:");
		scanf("%s", vex1);
		printf("临界点(与顶点相连的点):");
		scanf("%s", vex2);

		//分别获得两个顶点在顶点数组中的坐标
		//int x, y;
		int x = LocateVex(G, vex1);
		int y = LocateVex(G, vex2);
		if (x == -1 || y == -1)
		{
			return ERROR;
		}
		int value;
		printf("请输入权值:");
		scanf("%d", &value);
		G->arcs[x][y] = value;
		//无向图邻接表是对称的
		G->arcs[y][x] = G->arcs[x][y];

		free(vex1);
		free(vex2);
	}

	return OK;
}

//有向网就是把邻接矩阵的1改成权值就行
Status CreateDN(MarixGraph* G)
{
	G->kind = DN;//设置当前创建图的类型为无向图

	printf("请输入有向网的顶点数量\n");
	scanf("%d", &G->verTexCount);
	printf("边的数量\n");
	scanf("%d", &G->arcCount);

	printf("依次输入顶点信息\n");
	for (int i = 0; i < G->verTexCount; i++)
	{
		G->verTexS[i] = (VerTexType*)malloc(sizeof(VerTexType) * 10);//数组类型,整形的char类型
		printf("顶点%d:", i + 1);
		scanf("%s", G->verTexS[i]);
	}

	//初始邻接矩阵所有边的权值设置为0
	for (int i = 0; i < G->verTexCount; i++)
	{
		for (int j = 0; j < G->verTexCount; j++)
		{
			G->arcs[i][j] = INT_MAX;//默认为整形的最大值,作为无穷大
		}
	}

	printf("请输入顶点和临界顶点信息,构建邻接矩阵\n");
	for (int i = 0; i < G->arcCount; i++)
	{
		VerTexType* vex1 = (VerTexType*)malloc(sizeof(VerTexType) * 10);
		VerTexType* vex2 = (VerTexType*)malloc(sizeof(VerTexType) * 10);

		printf("顶点:");
		scanf("%s", vex1);
		printf("临界点(与顶点相连的点):");
		scanf("%s", vex2);

		//分别获得两个顶点在顶点数组中的坐标
		//int x, y;
		int x = LocateVex(G, vex1);
		int y = LocateVex(G, vex2);
		if (x == -1 || y == -1)
		{
			return ERROR;
		}
		int value;
		printf("请输入权值:");
		scanf("%d", &value);
		G->arcs[x][y] = value;
		//有向图的邻接矩阵有可能不对称
		//G->arcs[y][x] = G->arcs[x][y];

		free(vex1);
		free(vex2);
	}

	return OK;
}

//测试
void testMatrixGrqph()
{
	MarixGraph G;

	//创建无向图
	//Status status = CreateUDG(&G);

	//创建有向图
	//Status status = CreateDG(&G);
	
	//无向网
	//Status status = CreateUDN(&G);

	//有向网
	Status status = CreateDN(&G);

	if (status == ERROR)
	{
		printf("创建图失败,请检查后重试\n");
		return;
	}

	printf("打印图的邻接矩阵\n");
	printf("\t");
	for (int i = 0; i < G.verTexCount; i++)
	{
		printf("\t%s", G.verTexS[i]);
	}
	printf("\n");
	for (int i = 0; i < G.verTexCount; i++)
	{
		printf("\t%s", G.verTexS[i]);
		for (int j = 0; j < G.verTexCount; j++)
		{
			if (G.arcs[i][j] == INT_MAX)
			{
				printf("\tNULL");
			}
			else
			{
				printf("\t%d", G.arcs[i][j]);//网中的
			}
			//printf("\t%d", G.arcs[i][j]);//图中的
		}
		printf("\n");
	}
}



//////////////////////////////////////////G_mode.c
#define _CRT_SECURE_NO_WARNINGS 1

#include"MatrixGraph.h"

int main()
{
	testMatrixGrqph();
	return 0;
}

