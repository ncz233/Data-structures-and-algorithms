#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

//图的概念
// 线性结构 - 一对一
// 树形结构 - 一对多
// 图形结构 - 多对多
//
//
// 图的定义和基本术语
// 图的类型定义
// 图的存储结构
//	顺序存储结构 = 邻接矩阵表示法
//	链式存储结构 = 邻接表表示法
// 图的遍历
//	深度优先搜索(dfs)
//	广度优先搜索(bfs)
// 图的应用
//

//无向图
// 图:G = (V,E)	(可以把图比做成数学上的图,图的点叫顶点,边叫边懂?)
// V:顶点(数据元素)的有穷非空集合
// E:边的又穷集合
//
//有向图
// 有方向的边叫弧(zrc)使用有序偶<Vi,Vj>表示,有方向的边要写成<Vi,Vj>这样,只能有一种写法,头(开始的地方)写在前面,尾(指针指向的地方)写在后面
// 如果图中任意两个顶点之间的边都是有向边,则称该图为有向图
// 对于有向图G: G=(V,{E})
// 顶点集合:V = {V1.V2,V3.....};
// 边集合:E = {<V1,V2>,<V1,V3>.....};这要看图!!!!!
//
//完全图
// 任意两个顶点都有一条边相连的图叫做完全图
// 无向完全图边 = n(n-1)/2条边;(n是顶点个数)
// 有向完全图边 = n(n-1)条边;(因为需要来回相互指向)
// 对具有n个顶点和e条边的图
//  1.无向图: 0 <= e <= n*(n-1)/2;
//  2.有向图: 0 <= e <= n*(n-1);
// 
// 网
// 网是边或弧带权的图
//  图的边或弧所具有的相关数称为权(weight)
// 如:导航软件推荐最短路线问题建立的模型是有向网
//  无向网 = 边是无方向的,边上有权值的
//  有向网 = 边是有方向的,边上有权值的
// 
// 子图
//  假设有两个图: G1 = (V1,{E1})和G2 = (V2,{E2});
//  如果第二图的顶点 属于 第一图的顶点 且 第二图的边 属于 第一图的边,我们就称第二个图就是第一个图的子图
//  无向图和有向图都一样(注意有向图的边要匹配,如果不匹配那不是子图了)
// 
// 图的顶点和边的关系(无向图)
//  如果边(Vi,Vj)是属于边集合的(也就是E),则称顶点Vi和Vj互为邻接点(Adjacent)
//  边(Vi,Vj)依附于(incident)顶点Vi和Vj(或边与顶点相关联)
//  顶点V的度(Degree)是和V相关联的边的数量,记作TD(V)
//  无向图的边数为各顶点边数的一半
// 
// 图的顶点和边的关系(有向图)
// 前两个都一样
//  如果边(Vi,Vj)是属于边集合的(也就是E),则称顶点Vi和Vj互为邻接点(Adjacent)
//  边(Vi,Vj)依附于(incident)顶点Vi和Vj(或边与顶点相关联)
// 不一样
//  入度和出度
//  入度: 以顶点V为头的弧的数目称为V的入度(InDegree),记作ID(V)
//  出度: 以顶点V为尾的弧的数目称为V的入度(OutDegree),记作OD(V)
// 顶点V的度 TD(V) = ID(V) + OD(V)
// 结论: 有向图的弧度 = 总入度 = 总出度.
//
// 路径(path)
// 连续的边构成的有序顶点集合
//  无向图G = (V,{E})中,从顶点V1到顶点Vj的路径
//  注意:如果是有向图,则路径也应该是有向的
// 路径长度
//  指路径上的边或弧的数量
// 回路或环
//  第一个顶点到最后一个顶点相同的路径称为回路或环
// 简单回路或简单环
//  序列中顶点不重复出现的路径尾简单路径
//  除了第一个顶点和最后一个顶点外,其余顶点都不重复出现的回路
// 
// 连通图
//  在无向图G = (V,{E})中,若对任何两个顶点Vi,Vj都存在从Vi到Vj的路径,则称G是连通图(在有向图中称为 强连通图)
// 
// 定义与术语小结
//  图按照有无方向分为无向图和有向图
//   无向图由顶点和边构成,有向图由顶点和弧构成,弧有弧尾和弧头之分
//  如果任意两点之间都存在边,叫完全图;又想的叫做又向完全图
//   若无重复的边或顶点到自身的边则叫简单图
//  图中顶点之间有邻接点,依附的概念
//   无向图顶点的边数叫做度,有向图顶点分为入度和出度
//  图中的边或弧上带权就成为网
//  图中顶点间存在路径,两顶点存在路径就说明是连通图
//   如果路径最终回到起始点则称为环,当中不重复称为简单路径
//   若任意两顶点都是连通的,则图就是连通图,又向则称强连通图

//图的存储结构
// 图的形状多种多样,但是每个顶点的关系始终如一
// 如何存储图
//  数组(邻接矩阵)表示法 实际上就是二维数组
//  链式存储结构
//   多重链表
//    邻接表表示法(重点)(其他都是这个的变种)
//    邻接多重表
//    十字链表
// 图形表示法
//  顶点存储
//   顺序表
//   链表
//  边存储
//   邻接矩阵(二维数组)
//   邻接表
// 数组表示法
//  建立一个定点表和邻接矩阵(表示各顶点之间关系)
//  设图A = (V,E)有n个顶点,则图的邻接矩阵是一个二维数组A[n][m]
//   0代表n点和m点没有边,1则有边
//  因为二维数组是对称的可以A[n][m] = 1,a[m][n]=1;
//  在完全图的邻接矩阵中,对角元素为0,其余1
//  特点
//   无向图的邻接矩阵是对称的
//   顶点i的度=第i行(列)中的1个数
//

//做数组(邻接矩阵)的图或网
//使用邻接矩阵表示法创建无向图
//无向图的特点
// 无向图的邻接矩阵是对称的
// 顶点i的度 = 第i行(列)中1的个数
// 
//在有向图的邻接矩阵中
//  第i行含义:以节点vi为尾的弧(既出度边)
//  第i列含义:以节点vi为尾的弧(既入度边)
//有向图特点
// 有向图的邻接矩阵可能不是对称的
// 顶点的出度 = 第i行元素之和
// 顶点的入度 = 第i列元素之和
// 顶点的度 = 第i行元素之和 + 第i列元素之和
//
//网就是把1改成权值,把0改成随便的
//
//做链表(邻接表)的图或者网
// 用于作用在顶点多,且边少的图,以免用数组做的时候开辟空间太大,浪费空间
// 以链表(链表中有数组,也就是val值是数组)一起存储的方法:顶点是数组,边是每个顶点后面的链表,和哈希表的结构像,但是算法不同

//图的创建完成后小结
//图的逻辑结构与存储的映射
// 顺序存储结构借助数据工具矩阵
//  图形表示法映射为矩阵
//  矩阵映射为二维数组
// 链式存储结构(一共有三种,只做了一种,剩下的两种是这个链表的变种)
//  图形表示法映射为多重链表
// 
//邻接矩阵表示法与邻接表表示法的对比
// 邻接矩阵表示法
//  优点:容易实现图的操作,如:求某顶点的度,判断顶点之间是否有边,着顶点的邻接点等等
//  缺点:n个顶点需要n^2单元存储边,空间效率低.
// 邻接表表示法
//  优点:空间效率高,容易寻找到顶点的邻接点.
//  缺点:判断两顶点间是否有边或弧,需搜索两结点对应的单链表,没有邻接矩阵方便

//搜索
// 定义:根据问题的实际情况,不断寻找可莉用的知识,从而构造一条代价最小的推理路线,使问题得以解决的过程称之为搜索
//适用情况
// 难以获取求解所需的全部信息
// 更没有线程的算法可供求解使用
//
//计算机解决搜索问题
// 定义(图的遍历时图的基本运算)
//  从已知的连通图某一顶点出发,沿着一些边去访问遍历图中所有的顶点,且使每个顶点仅被访问一次,就叫做图的遍历
// 图的遍历的实质是找每个顶点的邻接点的过程
// 特点:图中可能存在回路且图的任一顶点都可能与其他顶点相通,在访问完某个顶点之后可能会沿着某些边又回到了曾经访问的顶点
//  两大类:深度优先搜索DFS(类似树的先序遍历),广度优先搜索BFS(类似树的层序遍历)
//
// 深度优先搜索
//  模仿树的先序遍历过程(数组)
//   先左边遍历,遍历完之后回溯到上一个点,然后在右边遍历,如果没有这个顶点没有其他边,那么在回溯,直到回溯到刚开始的顶点,看有没有其他顶点,如果有遍历,没有遍历完成打印去
//   访问图中某个起始顶点v1,由v出发,访问它的任一临界顶点v2,再从v2出发,访问与v2邻接但还未被访问过的顶点v3,然后从v3除法,进行类似的访问...如此进行下去,直至到达所有的临界顶点都被访问过的顶点v5为止
//   然后回溯到v1访问剩下的边v6,怎么回溯呢,接着退回一步,退到前一次刚访问过的顶点,看是否还有其他没有被访问的邻接顶点,如果没有就在退回一步进行搜索,之后在从此顶点出发,进行与前述类似的访问 
//   递归思路
//   重复上述的过程,直到联通图中所有的顶点都被访问过为止
//  模仿树的先序遍历过程(链表)
//   访问每个数组后面的链表,访问到链表后面的数据这个是数组的下标,然后暂时不在访问后面的结点该访问对应下标的数组
//    访问这个数组后面的链表,因为访问重复的有标记所以不访问重复的结点,直接访问没有访问的结点
//   直到最后一个数组的后面的链表全访问过了开始回退了(用递归来实现)
//   同理要有状态数组的,0为没有访问过,1访问过,被访问过的跳过这一步,一条路走完了,要回退
//



