#define _CRT_SECURE_NO_WARNINGS 1

//   树的操作 - 还是解决非线性用线性存储的问题
//    一般是二叉树的操作 - 用递归的思想去看
//     树的遍历 - 遍历
//      先序遍历(先访问根节点) - 先访问根节点，然后访问左子树，最后访问右子树
//      中序遍历(中间问根节点) - 先左子树，然后根节点，最后右子树
//      后序遍历(最后问根节点) - 先左子树，然后柚子树，最后根节点 nwtsfplqm
// 
//     已知两种遍历求原始的树 - 一种不行，还有先序和后序也不行
//      通过先序和中序，或者中序和后序我们可以还原出原始的二叉树。但是通过先序和后序是无法还原出原始的二叉树的
//      换种说法：只有先序和中序，或者中序和后序我们才可以唯一的确定一个二叉树
// 
// 
//   树的应用
//    树是数据库中数据组织一种重要形式
//    操作系统子父进程的关系本身就是一棵树
//    面向对象语言中类的继承关系本身就是一棵树
//    哈夫曼树本质就 - 是我们一个事物他有N种可能出现的取值 - 取值的概率都不一样 - 为了解决工作的效率达到最高 - 把数据发过去，这个数据可能是a,b,c,d,..，通过什么编码发过去的时候是我们速度是最快的效率是最高的所承受的空间是最少的，像这种类似的问题都是哈夫曼树。而哈夫曼树是我们树的一个颗粒


//根据中序和后序找到相应的根节点，再用中序找到子节点
//示例一
//先序:ABCDEFGH
//中序:BDCEAFHG
//后序:DECBHGFA

//实列2
//先序:ABDGHCEFI
//中序:GDHBAECIF
//后序:GHDBEIFCA

//实列3
//中序:BDCEAFHG
//后序:DECBHGFA
//先序:ABCDEFGH

//实列4
//让别人给你出题去
