#define _CRT_SECURE_NO_WARNINGS 1
#include<stdio.h>

//前排提示不懂画图!!!!!!!!!!!!!!!!!!!!!!!!!
// 数据结构与算法地位
//  数据结构是软件中最核心的内容
//   内存中栈和堆是怎么划分的，是算法不同，分配的算法不同。栈内存是压栈和出栈，堆内存是堆排序
//   操作系统中要知道队列是什么：牵扯到跟时间有关的东西总得先后顺序。先后顺序就会用存储数据的这种结构叫队列，队列是先后顺序
//   程序 = 数据结构(数据的存储) + 算法(数据的操作) + C语言(可以被计算机执行的语言)
//  我们看懂一个程序分为几步：1.流程，2.每个功能，3.试数
// 
// 
// 数据结构与算法概述
//  定义
//   我们如何把现实中大量而复杂的问题以特定的数据类型(个体)和特定的存储结构(个体和个体的关系)保存到主存储器(内存)中，
//   以及在此基础上为实现某个功能(比如查找某个元素，增删查改某个元素，对将所有元素进行排序)而执行的相应操作，
//   这个相应的操作也叫算法
//   (数据结构研究什么：把现实中的问题保存到计算机内存中(如何保存到硬盘,数据结构不研究这个)，分两块来保存1.个体如何来保存。2.个体和个体的关系来保存。完成这两个后数据的存储这个问题就解决了)
//   数据结构 = 个体 + 个体和个体的关系 (存储数据)
//   算法 = 对存储数据的操作 (操作数据)
//   (先讲)狭义的算法 = 算法是依附于存储数据的，存储的方式不一样，算法也就不一样
//   (后讲)广义(泛型)的算法 = 跟存储关系是没有关系的
//  算法
//   解题的方法和步骤
//   衡量算法的标准
//    时间复杂度 - 程序大概要执行的次数，而非执行时间
//    空间复杂度 - 执行过程中大概所占用的最大内存
//    难易程度 - 就是代码可读性
//    健壮性(鲁棒性)  - 就是写代码要考虑周全。任何情况下都无懈可击，维护性也在里面
// 
// 
// 预备知识(day01 - 02)
//  这个不算预备知识(伪算法：被描述的算法可以容易地以任何一种编程语言实现，看是很容易去看懂，但是实现它很难！)
//  指针
//   指针的重要性 - 指针是C语言从灵魂
//  定义
//   地址 - 内存单元的编号
//    (cpu跟内存有三根线，1.地址线(定位)。2.控制线(控制那个位置读和写)。3.数据线。补充：C语言中访问内存单元的编号是(从0开始的非负整数)0--FFFFFFFF[0 - 4G-1]因为C语言是从0开始的)仅次于32位机器，64位是0--FFFFFFFFFFFFFFFF[0 - 8G-1]
//   指针概念
//    指针就是地址，地址就是指针
//    指针变量是存放内存单元地址的变量
//    指针的本质是一个操作受限的非负整数
//   分类
//    基本类型的指针
//    指针和数组的关系
//  结构体(c++有类，c++的类比c语言的结构体要完全)
//   为什么会出现结构体
//    定义一个复杂对象需要用结构体。如：学生，有姓名，年龄，学号....
//   什么叫做结构体
//    结构体是用户根据实际需要自己定义的复合数据类型
//   如何使用结构体
//    看day02 - 新plus的64行
//   注意事项
//    结构体变量，不能相互加减乘除，但可以相互赋值
//    结构体变量和结构体指针变量作为函数传参的问题
//  动态内存的分配和释放
//   开辟多少字节malloc，开辟成功，返回起始地址，开辟失败，返回空指针
//   calloc开辟一块连续空间 - 会初始化内存为0
//   realloc - 给指针指向的空间增加空间大小
//   它们都是与free一对的，free是释放的意思。没释放会内存泄露
//
// 
// 模块一：线性结构-(物理上不是连续，逻辑上是连续的)(数组day03，链表04-)
//  连续的存储[数组]
//   什么叫数组
//    元素类型相同，大小相等
//   确定一个链表需要几个参数
//    首地址，长度，有效的个数
//   数组的优缺点
//    跟链表比较
// 
//  离散(不连续)的存储[链表]
//   定义
//    n个结点离散分配
//    彼此通过指针相连
//    每个结点只有一个前驱结点和后续结点(双向链表)
//    首结点没有前驱结点，尾结点没有后续结点(单链表)
//    1.物理层不连续(逻辑层连续)。2.指针指针指向下一个结点。3.线性(一对一)(与树的区别是:链表不劈叉，树劈叉)
//   专业术语
//    首结点：第一个存有效数据的结点
//    尾结点：最后一个存有效数据的结点
//    头节点：头节点的数据类型和首结点的数据类型一样。在首结点前加上一个结点。不存有效数据，也没存放整个链表的有效个数，但是它属于链表中的结点，它有数据类型(和首结点的数据类型一样)也就是他有空间(空间和其它结点的空间一样)但没有数据。
//     我们对链表进行操作的时候，在前面加上没有实际含义的头节点可以方便我们对链表的操作(哨兵位)
//    头指针：指向头节点的指针变量(指向这个链表的地址的指针，链表的地址是链表第一个结点(不管是存没存有效数据，也就是可以头节点))
//    尾指针：指向尾结点的指针变量
//    确定一个链表需要几个参数：至少需要一个参数 - 头指针(只需要告诉指向这个链表地址的指针)，因为我们通过头指针可以推算出链表的其他所有信息。(数组是：首地址，长度，有效的个数)
//   分类
//    单链表(单向链表)(普通的单链表是不带头且不循环的)：每个结点有一个指针域，这个指针域是指向下一个整体的地址
//    双链表(双向链表)(普通的双链表是带头且循环的)：每一个结点有两个指针域，一个指向上一个整体的地址，一个指向下一个整体的地址
//    循环链表：能通过任何一个结点找到其他所有的结点
//    非循环链表：其中一个结点指向空(NULL)，而那个结点称为尾结点
//   算法
//    遍历：能找到所有的元素
//    查找：查到一个元素，并找到
//    清空：除了头节点全部木大
//    销毁：全都木大
//    求长度：字面意思
//    排序：用合适的算法做排序
//    删除结点：某一个位置上删除结点 - 先存储上要删除的结点(因为要释放)，要删除的结点的上一个结点指针指向要删除的结点的下一个结点，然后要释放要删除的结点
//    插入结点：某一个位置上插入结点 - 新结点的指针指向要插入位置的后一个结点，然后前一个结点的指针指向新结点。或者拿一个指针指向要插入位置的后一个结点，前一个结点的指针指向新结点，新节点的指针指向要插入位置的后一个结点。
//    算法(重申一遍)
//     狭义的算法是与数据的存储方式密切相关的 - 最底层的实践说肯定不一样(可以理解成数学的公式，多个问题不能用同一个公式来解)
//     广义(泛型)的算法是与数据的存储方式无关 - 写的是一模一样，但是最底层的操作是不一样的(可以理解成数学的公式，多个问题能用同一个公式来解，但是接替思路是不同的)
//      泛型(泛型是广义，但是学完c++之后才会接触泛型这个是介绍：广义的底层操作的详细版) - 利用某种技术达到的效果 - 不同的存储方式，执行的操作是一样的(两个题的数都不一样，却能用同一种方法解(前提必须要把其中一个数转变成和另一个数相同的数))
//   怎么学算法
//    看到一个算法时不要想自己能一个人解决了，这是数学上的知识。不知道这么做先把别人的答案给看懂，由不懂到看懂，分三步，流程、每个语句的功能、试数。重要的是要把答案给看懂
//   链表的优缺点
//    跟数组比较
// 
// 线性结构的两种常见应用之一 - 栈
// 线性结构的两种常见应用之二 - 队列
// 专题：递归
//  1.1+2+3+4+...100的和
//  2.求阶乘
//  3.汉诺塔
//  4.走迷宫
// 
// 
// 模块二：非线性结构
//  树
//   (可以看成某公司人事图，最上面是老板，然后是领导(领导也不只是一个吧，有多个)，最后一个领导下有多个员工。每一个人事看成一个结点)
//  图
//   任何一个结点都可能与另外的结点产生联系-(可以看成城市交通图，每个站点看成一个结点。怎么用：求一个结点到另一个结点的最短路径)
// 
// 模块三：查找和排序
//  折半查找
//  排序：冒泡，插入，选择，快速排序，归并排序...
// 
// java中容器和数据结构相关知识
//  Iterator接口
//  MAP：哈希表


//复习指针
//C语言变量使用前必须要初始化，不初始化，它的变量会是其他软甲遗留下来的垃圾数据
// 软件运行前要向操作系统申请存储空间，在内存剩下的空间足够时，操作系统将分配一段内存空间并将外存中软件拷贝一份进入该内存空间中，并启动该软件
// 在软件运行期间，该软件所占内存空间不在分配给其他软件
// 当软件运行完毕后，操作系统将回收该内存空间(注：操作系统并不清空该内存空间中遗留下来的数据)，以便再次分配给其他软件使用。
//注意：指针变量也是变量，只不过它存储的不能时内存单元的内容，只能存放内存单元的地址
// 普通变量前不能加*
// 常量和表达式前不能加&
//指针的运算
// p+i的值是p + i*p所指向的变量所占的字节数
// p-i的值是p - i*p所指向的变量所占的字节数
// p++ == p+1;
// p-- == p-1;
//

//int main()
//{
//	int* p;//p是个变量名字，int*表示该p变量只能存储int类型变量的类型
//	int i = 10;
//	int j;
//
//	p = &i;//这里*p = i
//	//p = 10;//err
//	j = *p;
//	printf("i = %d,j = %d,*p = %d\n",i,j,*p);
//
//	return 0;
//}

//void f(int* p)//不是定义了一个名字叫*p的形参，而是定义了一个形参，该形参名字叫做p，它的类型时int*
//{
//	*p = 10;//*p = i
//}
//
//int main()
//{
//	int i = 9;
//	f(&i);
//	printf("%d\n", i);
//
//	return 0;
//}

//int main()
//{
//	int a[5] = { 1,2,3,4,5};//a存储是数组首元素的地址。a+1,a是首元素地址加1下标，所以是首元素地址向后移1位地址。a+3，a是首元素地址加3下标，所以首元素地址往后移动3位
//	//总结你看到的是a[n+1]的内容
//	//a[3] == *(a + 3);//前面加个*号就可以访问该下标的地址
//	//3[a];//3[a]和a[3]是一样的
//	printf("%p\n", a);
//	printf("%p\n", a+1);//可以这么想，a的地址 + a所占空间的大小*移动多少下标
//	printf("%d\n", *a + 2);//*a + 2 = *(a + 2) = a[0]+2 = a[2]
//	return 0;
//}

void ShowArray(int* p,int len)//但是p[]这样写也行
{
	//p[2] = -1;//p[0] == *p,p[2] == *(p+2) == *(a+2) == a[2]
	//p[i]就是主函数的a[i]

	for (int i = 0; i < len; i++)
	{
		printf("%d\n", p[i]);
	}
}
int main()
{
	int a[5] = { 1,2,3,4,5 };
	ShowArray(a,5);//a等价于&a[0],&a[0] = *(a+0) = *(a),类型是int*
	//printf("%d\n", a[2]);

	return 0;
}
