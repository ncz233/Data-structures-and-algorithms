#define _CRT_SECURE_NO_WARNINGS 1
//算法
// 了解算法的基本需求
// 掌握推到大O阶的方法
// 会计算算法的时间复杂度和空间复杂度
// 掌握查找算法的评论指标
// 掌握常见的查找算法	重点
// 掌握五种基本的排序算法	重点
//
//算法的定义和特性
//定义
// 算法是解决特定的问题求解步骤的描述,在计算机中保险为指令的优先序列,并且每条指令表示一个或多个操作
// 同一个问题可能会有很多种不同的算法
// 没有通用的算法能解决所有问题
//特性
// 有穷性:算法在不能死循环,可接受的时间内完成
// 确定性:算法的每一步步骤都有确定性,不是二义性,这个步骤是到底干嘛的
// 可行性:算法的每一步执行有限的次数来完成
// 
// 算法设计的需求
//  正确性:算法至少应该具有输入,输出和加工处理无歧义性,能正确反应问题的需求,能够得到问题的正确答案
//   1.算法程序没有语法错误
//   2.算法程序对于合法的输入数据能够产生满足需求的输入结果
//   3.算法程序对于非法的输入数据能够得出满足规格说明的结果
//   4.算法程序对于精心选择的,甚至刁难的测试数据都有满足需求的输出结果
//  可读性:算法设计的另一个目的是为了方便阅读,理解和交流
//   注意:代码并不是越少越好,过度追求"最少代码",会导致绝对多数人看不懂这种代码,降低了可读性,是算法设计中的大忌
//  鲁棒性:当输入数据不合法时,算法也能够做出相关的处理,而不是产生异常或莫名其妙的结果
// 好的算法:时间效率高,存储空间低
// 
// 算法效率度量
//  事后统计方法
//   通过设计好的测试程序和数据,利用计算机计时器对不同算法编制的程序的运行时间进行计较,从而确定算法效率的高低
// 事后统计方法的缺陷(比较费时间)
//  必须依据算法实现编制好程序,这通常需要花费大量的时间和经历
//  时间必须依赖计算机硬件和软件等环境因素,有时会掩盖算法本身的优劣
//  算法的测试数据设计困难,并且程序的运行时间往往还与测试数据的规模有很大关系
//
// 什么是事前分析估算方法
//  在计算机程序编制前,依据统计方法对算法进行估算
// 决定计算程序运行时间的因素
//  算法采用的策略,方法
//  编译产生的代码质量(软件支持)
//  问题的规模:指令输入量的多少
//  机器执行指令的速度
//   在分析程序的运行时间,最重要的是把程序看成是独立于程序设计语言的算法或一系列步骤
// 计算算法效率是取最大的就是了如:n^2
//  判断一个算法效率时,函数中的常数和其他次要项常常可以忽略,而更应该关注最高阶项的阶数
// 
//算法的时间复杂度(只找最高阶项)
// 定义 (一般情况下,随着n的增大,T(n)的增长最慢的算法为最优算法)
//  算法的时间复杂度就是算法时间度量, 记作:T(n) = O(f(n))
//  T(n)表示语句总的执行次数,它时关于问题规模n的函数
//  用O()来体现算法时间复杂度的记法,我们称之为daO记法
//推到大O阶的方法
// 用常数1取代运行时间中的所有加法常数
// 在修改后的运行次数函数中,只保留最高阶项
// 如果最高阶存在且不是1,去吃这个项相乘的常数
// 常数阶
//  根据推导大O阶方法,常数阶的时间复杂度均为O(1)
// 线性阶
//  根据推导大O阶方法,线性阶的时间复杂度均为O(n)
// 平方阶
//  根据推导大O阶方法,平方阶的时间复杂度均为O(n^2)
// 对数阶
//  根据推导大O阶方法,对数阶的时间复杂度均为O(log n)
//
//常见的时间复杂度
// O(1)	常数阶
// O(n)	线性阶
// O(n^2)	平方阶
// O(log n)	对数阶
// O(nlog n)	nlog n 阶
// O(n^3)	立方阶
// O(n^n)	指数阶
//从小到大依次排序
// O(1) < O(log n) < O(n) < O(nlog n) < O(n^2) < O(n^3) < O(n^n)
//
//算法的空间复杂度
// 定义(如果算法执行所需要的辅助空间相对于数据量而言是个常数,则称此算法为原地工作,空间复杂度为O(1))
//  算法的空间复杂度通过计算算法所需要的存储空间实现
//  算法的空间复杂度的计算公式记作:S(n) = O(f(n)),其中n为问题的规模,f(n)为语句关于n所占存储空间的函数
// 算法优劣判定的基本原则
//  优先判断时间复杂度的优劣
//  时间复杂度相同,再判断空间复杂度的优劣 
// 
//回顾数据结构
// 数据结构
//  逻辑结构
//   线性结构(线性表,栈,队列,串)
//   树形结构(树,二叉树)
//   图形结构(图)
// 
//  存储结构
//   顺序存储结构
//   链式存储结构
// 
//  数据运算
//   插入运算
//   删除运算
//   修改运算
//   查找运算
//   排序运算
//
// 什么是查找
//  查找是根据给定的某个值,再查找表中确定的某个值,在查找表中确定一个其关键字等于给定的数据元素(或者记录)
// 查找表:由同一类型的数据元素(记录)构成的集合
// 关键字:记录中某个数据项的值,可用来识别一个记录
//  主关键字:唯一表示数据元素
//  次关键字:可以表示若干个数据元素
//
//ASL:关键字的品爵比较次数,也称平均搜索长度,网上找数学公式去
//顺序查找
// 应用范围
//  顺序表或者链表表示的静态查找表
//  表内的元素之间是无序的
//  
//顺序查找算法的特点:
// 算法简单,对表结构无任何要求(顺序和链式)
// n很大时查找效率较低, 不如二分查找(但是需要排序好)
// 时间复杂度平均的: (n+1)/2, 不成功是(n+1)次
// 空间复杂度:辅助空间,哨兵位
// 
//有序表查找(被称为折半查找又称二分法)
// 因应范围
//  线性表中的记录是有序的,一般按照从小到大的顺序排序
// 基本思想
//  在有序表中,取中间值和要查找的值比较
//  若等于中间值,则中间值即为要查找的
//  若小于中间值,则中间的左半区域继续查找
//  若大于中间值,则中间的右半区域继续查找
//  不断重复上述过程
//
//
